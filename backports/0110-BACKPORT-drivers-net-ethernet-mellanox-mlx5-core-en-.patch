From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT:
 drivers/net/ethernet/mellanox/mlx5/core/en/reporter_tx.c

Change-Id: I90afad600e2eb80cc9899c396a5a2a7327bdd9f0
---
 .../mellanox/mlx5/core/en/reporter_tx.c       | 245 +++++++++++++++++-
 1 file changed, 235 insertions(+), 10 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/en/reporter_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/reporter_tx.c
@@ -130,6 +130,7 @@ static int mlx5e_tx_reporter_timeout_rec
 	return err;
 }
 
+#ifdef HAVE_DEVLINK_HEALTH_REPORT_SUPPORT
 /* state lock cannot be grabbed within this function.
  * It can cause a dead lock or a read-after-free.
  */
@@ -139,8 +140,11 @@ static int mlx5e_tx_reporter_recover_fro
 }
 
 static int mlx5e_tx_reporter_recover(struct devlink_health_reporter *reporter,
-				     void *context,
-				     struct netlink_ext_ack *extack)
+		                     void *context
+#ifdef HAVE_HEALTH_REPORTER_RECOVER_HAS_EXTACK
+                                    , struct netlink_ext_ack *extack
+#endif
+                                    )
 {
 	struct mlx5e_priv *priv = devlink_health_reporter_priv(reporter);
 	struct mlx5e_err_ctx *err_ctx = context;
@@ -149,15 +153,33 @@ static int mlx5e_tx_reporter_recover(str
 			 mlx5e_health_recover_channels(priv);
 }
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+static void
+#else
 static int
+#endif
 mlx5e_tx_reporter_build_diagnose_output_sq_common(struct devlink_fmsg *fmsg,
 						  struct mlx5e_txqsq *sq, int tc)
 {
 	bool stopped = netif_xmit_stopped(sq->txq);
 	struct mlx5e_priv *priv = sq->priv;
 	u8 state;
+#ifdef HAVE_INT_DEVLINK_FMSG_U8_PAIR
 	int err;
+#endif
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5_core_query_sq_state(priv->mdev, sq->sqn, &state);
+	devlink_fmsg_u32_pair_put(fmsg, "tc", tc);
+	devlink_fmsg_u32_pair_put(fmsg, "txq ix", sq->txq_ix);
+	devlink_fmsg_u32_pair_put(fmsg, "sqn", sq->sqn);
+	devlink_fmsg_u8_pair_put(fmsg, "HW state", state);
+	devlink_fmsg_bool_pair_put(fmsg, "stopped", stopped);
+	devlink_fmsg_u32_pair_put(fmsg, "cc", sq->cc);
+	devlink_fmsg_u32_pair_put(fmsg, "pc", sq->pc);
+	mlx5e_health_cq_diag_fmsg(&sq->cq, fmsg);
+	mlx5e_health_eq_diag_fmsg(sq->cq.mcq.eq, fmsg);
+#else
 	err = mlx5_core_query_sq_state(priv->mdev, sq->sqn, &state);
 	if (err)
 		return err;
@@ -195,12 +217,23 @@ mlx5e_tx_reporter_build_diagnose_output_
 		return err;
 
 	return mlx5e_health_eq_diag_fmsg(sq->cq.mcq.eq, fmsg);
+#endif
 }
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+static void
+#else
 static int
+#endif
 mlx5e_tx_reporter_build_diagnose_output(struct devlink_fmsg *fmsg,
 					struct mlx5e_txqsq *sq, int tc)
 {
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	devlink_fmsg_obj_nest_start(fmsg);
+	devlink_fmsg_u32_pair_put(fmsg, "channel ix", sq->ch_ix);
+	mlx5e_tx_reporter_build_diagnose_output_sq_common(fmsg, sq, tc);
+	devlink_fmsg_obj_nest_end(fmsg);
+#else
 	int err;
 
 	err = devlink_fmsg_obj_nest_start(fmsg);
@@ -220,12 +253,26 @@ mlx5e_tx_reporter_build_diagnose_output(
 		return err;
 
 	return 0;
+#endif
 }
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+static void
+#else
 static int
+#endif
 mlx5e_tx_reporter_build_diagnose_output_ptpsq(struct devlink_fmsg *fmsg,
 					      struct mlx5e_ptpsq *ptpsq, int tc)
 {
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	devlink_fmsg_obj_nest_start(fmsg);
+	devlink_fmsg_string_pair_put(fmsg, "channel", "ptp");
+	mlx5e_tx_reporter_build_diagnose_output_sq_common(fmsg, &ptpsq->txqsq, tc);
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "Port TS");
+	mlx5e_health_cq_diag_fmsg(&ptpsq->ts_cq, fmsg);
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+	devlink_fmsg_obj_nest_end(fmsg);
+#else
 	int err;
 
 	err = devlink_fmsg_obj_nest_start(fmsg);
@@ -257,12 +304,29 @@ mlx5e_tx_reporter_build_diagnose_output_
 		return err;
 
 	return 0;
+#endif
 }
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+static void
+#else
 static int
+#endif
 mlx5e_tx_reporter_diagnose_generic_txqsq(struct devlink_fmsg *fmsg,
 					 struct mlx5e_txqsq *txqsq)
 {
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	bool real_time =  mlx5_is_real_time_sq(txqsq->mdev);
+	u32 sq_sz = mlx5_wq_cyc_get_size(&txqsq->wq);
+	u32 sq_stride = MLX5_SEND_WQE_BB;
+
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "SQ");
+	devlink_fmsg_u64_pair_put(fmsg, "stride size", sq_stride);
+	devlink_fmsg_u32_pair_put(fmsg, "size", sq_sz);
+	devlink_fmsg_string_pair_put(fmsg, "ts_format", real_time ? "RT" : "FRC");
+	mlx5e_health_cq_common_diag_fmsg(&txqsq->cq, fmsg);
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+#else
 	u32 sq_stride, sq_sz;
 	bool real_time;
 	int err;
@@ -292,12 +356,22 @@ mlx5e_tx_reporter_diagnose_generic_txqsq
 		return err;
 
 	return mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+#endif
 }
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+static void
+#else
 static int
+#endif
 mlx5e_tx_reporter_diagnose_generic_tx_port_ts(struct devlink_fmsg *fmsg,
 					      struct mlx5e_ptpsq *ptpsq)
 {
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "Port TS");
+	mlx5e_health_cq_common_diag_fmsg(&ptpsq->ts_cq, fmsg);
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+#else
 	int err;
 
 	err = mlx5e_health_fmsg_named_obj_nest_start(fmsg, "Port TS");
@@ -309,9 +383,14 @@ mlx5e_tx_reporter_diagnose_generic_tx_po
 		return err;
 
 	return mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+#endif
 }
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+static void
+#else
 static int
+#endif
 mlx5e_tx_reporter_diagnose_common_config(struct devlink_health_reporter *reporter,
 					 struct devlink_fmsg *fmsg)
 {
@@ -319,8 +398,14 @@ mlx5e_tx_reporter_diagnose_common_config
 	struct mlx5e_txqsq *generic_sq = priv->txq2sq[0];
 	struct mlx5e_ptp *ptp_ch = priv->channels.ptp;
 	struct mlx5e_ptpsq *generic_ptpsq;
+#ifdef HAVE_INT_DEVLINK_FMSG_U8_PAIR
 	int err;
+#endif
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "Common Config");
+	mlx5e_tx_reporter_diagnose_generic_txqsq(fmsg, generic_sq);
+#else
 	err = mlx5e_health_fmsg_named_obj_nest_start(fmsg, "Common Config");
 	if (err)
 		return err;
@@ -328,12 +413,19 @@ mlx5e_tx_reporter_diagnose_common_config
 	err = mlx5e_tx_reporter_diagnose_generic_txqsq(fmsg, generic_sq);
 	if (err)
 		return err;
+#endif
 
 	if (!ptp_ch || !test_bit(MLX5E_PTP_STATE_TX, ptp_ch->state))
 		goto out;
 
 	generic_ptpsq = &ptp_ch->ptpsq[0];
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "PTP");
+	mlx5e_tx_reporter_diagnose_generic_txqsq(fmsg, &generic_ptpsq->txqsq);
+	mlx5e_tx_reporter_diagnose_generic_tx_port_ts(fmsg, generic_ptpsq);
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+#else
 	err = mlx5e_health_fmsg_named_obj_nest_start(fmsg, "PTP");
 	if (err)
 		return err;
@@ -350,24 +442,40 @@ mlx5e_tx_reporter_diagnose_common_config
 	if (err)
 		return err;
 
+#endif
 out:
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+#else
 	return mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+#endif
 }
 
 static int mlx5e_tx_reporter_diagnose(struct devlink_health_reporter *reporter,
-				      struct devlink_fmsg *fmsg,
-				      struct netlink_ext_ack *extack)
+				      struct devlink_fmsg *fmsg
+#ifdef HAVE_HEALTH_REPORTER_RECOVER_HAS_EXTACK
+                                      , struct netlink_ext_ack *extack
+#endif
+                                     )
 {
 	struct mlx5e_priv *priv = devlink_health_reporter_priv(reporter);
 	struct mlx5e_ptp *ptp_ch = priv->channels.ptp;
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	int i, tc;
+#else
 	int i, tc, err = 0;
+#endif
 
 	mutex_lock(&priv->state_lock);
 
 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state))
 		goto unlock;
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_tx_reporter_diagnose_common_config(reporter, fmsg);
+	devlink_fmsg_arr_pair_nest_start(fmsg, "SQs");
+#else
 	err = mlx5e_tx_reporter_diagnose_common_config(reporter, fmsg);
 	if (err)
 		goto unlock;
@@ -375,6 +483,7 @@ static int mlx5e_tx_reporter_diagnose(st
 	err = devlink_fmsg_arr_pair_nest_start(fmsg, "SQs");
 	if (err)
 		goto unlock;
+#endif
 
 	for (i = 0; i < priv->channels.num; i++) {
 		struct mlx5e_channel *c = priv->channels.c[i];
@@ -382,15 +491,26 @@ static int mlx5e_tx_reporter_diagnose(st
 		for (tc = 0; tc < mlx5e_get_dcb_num_tc(&priv->channels.params); tc++) {
 			struct mlx5e_txqsq *sq = &c->sq[tc];
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+			mlx5e_tx_reporter_build_diagnose_output(fmsg, sq, tc);
+#else
 			err = mlx5e_tx_reporter_build_diagnose_output(fmsg, sq, tc);
 			if (err)
 				goto unlock;
+#endif
 		}
 	}
 
 	if (!ptp_ch || !test_bit(MLX5E_PTP_STATE_TX, ptp_ch->state))
 		goto close_sqs_nest;
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	for (tc = 0; tc < mlx5e_get_dcb_num_tc(&priv->channels.params); tc++)
+		mlx5e_tx_reporter_build_diagnose_output_ptpsq(fmsg,
+				&ptp_ch->ptpsq[tc],
+				tc);
+
+#else
 	for (tc = 0; tc < mlx5e_get_dcb_num_tc(&priv->channels.params); tc++) {
 		err = mlx5e_tx_reporter_build_diagnose_output_ptpsq(fmsg,
 								    &ptp_ch->ptpsq[tc],
@@ -398,15 +518,24 @@ static int mlx5e_tx_reporter_diagnose(st
 		if (err)
 			goto unlock;
 	}
+#endif
 
 close_sqs_nest:
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	devlink_fmsg_arr_pair_nest_end(fmsg);
+#else
 	err = devlink_fmsg_arr_pair_nest_end(fmsg);
 	if (err)
 		goto unlock;
+#endif
 
 unlock:
 	mutex_unlock(&priv->state_lock);
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	return 0;
+#else
 	return err;
+#endif
 }
 
 static int mlx5e_tx_reporter_dump_sq(struct mlx5e_priv *priv, struct devlink_fmsg *fmsg,
@@ -414,17 +543,30 @@ static int mlx5e_tx_reporter_dump_sq(str
 {
 	struct mlx5_rsc_key key = {};
 	struct mlx5e_txqsq *sq = ctx;
+#ifdef HAVE_INT_DEVLINK_FMSG_U8_PAIR
 	int err;
+#endif
 
 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state))
 		return 0;
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "SX Slice");
+#else
 	err = mlx5e_health_fmsg_named_obj_nest_start(fmsg, "SX Slice");
 	if (err)
 		return err;
 
+#endif
+
 	key.size = PAGE_SIZE;
 	key.rsc = MLX5_SGMT_TYPE_SX_SLICE_ALL;
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "SQ");
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "QPC");
+#else
 	err = mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);
 	if (err)
 		return err;
@@ -440,11 +582,17 @@ static int mlx5e_tx_reporter_dump_sq(str
 	err = mlx5e_health_fmsg_named_obj_nest_start(fmsg, "QPC");
 	if (err)
 		return err;
+#endif
 
 	key.rsc = MLX5_SGMT_TYPE_FULL_QPC;
 	key.index1 = sq->sqn;
 	key.num_of_obj1 = 1;
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "send_buff");
+#else
 	err = mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);
 	if (err)
 		return err;
@@ -456,9 +604,18 @@ static int mlx5e_tx_reporter_dump_sq(str
 	err = mlx5e_health_fmsg_named_obj_nest_start(fmsg, "send_buff");
 	if (err)
 		return err;
+#endif
 
 	key.rsc = MLX5_SGMT_TYPE_SND_BUFF;
 	key.num_of_obj2 = MLX5_RSC_DUMP_ALL;
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+
+	return 0;
+#else
 	err = mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);
 	if (err)
 		return err;
@@ -468,6 +625,7 @@ static int mlx5e_tx_reporter_dump_sq(str
 		return err;
 
 	return mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+#endif
 }
 
 static int mlx5e_tx_reporter_timeout_dump(struct mlx5e_priv *priv, struct devlink_fmsg *fmsg,
@@ -483,17 +641,30 @@ static int mlx5e_tx_reporter_dump_all_sq
 {
 	struct mlx5e_ptp *ptp_ch = priv->channels.ptp;
 	struct mlx5_rsc_key key = {};
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	int i, tc;
+#else
 	int i, tc, err;
+#endif
 
 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state))
 		return 0;
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_fmsg_named_obj_nest_start(fmsg, "SX Slice");
+#else
 	err = mlx5e_health_fmsg_named_obj_nest_start(fmsg, "SX Slice");
 	if (err)
 		return err;
+#endif
 
 	key.size = PAGE_SIZE;
 	key.rsc = MLX5_SGMT_TYPE_SX_SLICE_ALL;
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);
+	mlx5e_health_fmsg_named_obj_nest_end(fmsg);
+	devlink_fmsg_arr_pair_nest_start(fmsg, "SQs");
+#else
 	err = mlx5e_health_rsc_fmsg_dump(priv, &key, fmsg);
 	if (err)
 		return err;
@@ -505,6 +676,7 @@ static int mlx5e_tx_reporter_dump_all_sq
 	err = devlink_fmsg_arr_pair_nest_start(fmsg, "SQs");
 	if (err)
 		return err;
+#endif
 
 	for (i = 0; i < priv->channels.num; i++) {
 		struct mlx5e_channel *c = priv->channels.c[i];
@@ -512,9 +684,13 @@ static int mlx5e_tx_reporter_dump_all_sq
 		for (tc = 0; tc < mlx5e_get_dcb_num_tc(&priv->channels.params); tc++) {
 			struct mlx5e_txqsq *sq = &c->sq[tc];
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+			mlx5e_health_queue_dump(priv, fmsg, sq->sqn, "SQ");
+#else
 			err = mlx5e_health_queue_dump(priv, fmsg, sq->sqn, "SQ");
 			if (err)
 				return err;
+#endif
 		}
 	}
 
@@ -522,13 +698,22 @@ static int mlx5e_tx_reporter_dump_all_sq
 		for (tc = 0; tc < mlx5e_get_dcb_num_tc(&priv->channels.params); tc++) {
 			struct mlx5e_txqsq *sq = &ptp_ch->ptpsq[tc].txqsq;
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+			mlx5e_health_queue_dump(priv, fmsg, sq->sqn, "PTP SQ");
+#else
 			err = mlx5e_health_queue_dump(priv, fmsg, sq->sqn, "PTP SQ");
 			if (err)
 				return err;
+#endif
 		}
 	}
 
+#ifndef HAVE_INT_DEVLINK_FMSG_U8_PAIR
+	devlink_fmsg_arr_pair_nest_end(fmsg);
+	return 0;
+#else
 	return devlink_fmsg_arr_pair_nest_end(fmsg);
+#endif
 }
 
 static int mlx5e_tx_reporter_dump_from_ctx(struct mlx5e_priv *priv,
@@ -539,8 +724,11 @@ static int mlx5e_tx_reporter_dump_from_c
 }
 
 static int mlx5e_tx_reporter_dump(struct devlink_health_reporter *reporter,
-				  struct devlink_fmsg *fmsg, void *context,
-				  struct netlink_ext_ack *extack)
+				  struct devlink_fmsg *fmsg, void *context
+#ifdef HAVE_HEALTH_REPORTER_RECOVER_HAS_EXTACK
+                                  , struct netlink_ext_ack *extack
+#endif
+                                 )
 {
 	struct mlx5e_priv *priv = devlink_health_reporter_priv(reporter);
 	struct mlx5e_err_ctx *err_ctx = context;
@@ -548,6 +736,7 @@ static int mlx5e_tx_reporter_dump(struct
 	return err_ctx ? mlx5e_tx_reporter_dump_from_ctx(priv, err_ctx, fmsg) :
 			 mlx5e_tx_reporter_dump_all_sqs(priv, fmsg);
 }
+#endif /* HAVE_DEVLINK_HEALTH_REPORT_SUPPORT */
 
 void mlx5e_reporter_tx_err_cqe(struct mlx5e_txqsq *sq)
 {
@@ -557,7 +746,9 @@ void mlx5e_reporter_tx_err_cqe(struct ml
 
 	err_ctx.ctx = sq;
 	err_ctx.recover = mlx5e_tx_reporter_err_cqe_recover;
-	err_ctx.dump = mlx5e_tx_reporter_dump_sq;
+#ifdef HAVE_DEVLINK_HEALTH_REPORT_SUPPORT
+       err_ctx.dump = mlx5e_tx_reporter_dump_sq;
+#endif /* HAVE_DEVLINK_HEALTH_REPORT_SUPPORT */
 	snprintf(err_str, sizeof(err_str), "ERR CQE on SQ: 0x%x", sq->sqn);
 
 	mlx5e_health_report(priv, priv->tx_reporter, err_str, &err_ctx);
@@ -573,7 +764,9 @@ int mlx5e_reporter_tx_timeout(struct mlx
 	to_ctx.sq = sq;
 	err_ctx.ctx = &to_ctx;
 	err_ctx.recover = mlx5e_tx_reporter_timeout_recover;
+#ifdef HAVE_DEVLINK_HEALTH_REPORT_SUPPORT
 	err_ctx.dump = mlx5e_tx_reporter_timeout_dump;
+#endif
 	snprintf(err_str, sizeof(err_str),
 		 "TX timeout on queue: %d, SQ: 0x%x, CQ: 0x%x, SQ Cons: 0x%x SQ Prod: 0x%x, usecs since last trans: %u",
 		 sq->ch_ix, sq->sqn, sq->cq.mcq.cqn, sq->cc, sq->pc,
@@ -583,22 +776,45 @@ int mlx5e_reporter_tx_timeout(struct mlx
 	return to_ctx.status;
 }
 
+#ifdef HAVE_DEVLINK_HEALTH_REPORT_SUPPORT
 static const struct devlink_health_reporter_ops mlx5_tx_reporter_ops = {
 		.name = "tx",
 		.recover = mlx5e_tx_reporter_recover,
 		.diagnose = mlx5e_tx_reporter_diagnose,
 		.dump = mlx5e_tx_reporter_dump,
 };
+#endif
 
 #define MLX5_REPORTER_TX_GRACEFUL_PERIOD 500
 
 void mlx5e_reporter_tx_create(struct mlx5e_priv *priv)
 {
+#ifndef HAVE_DEVLINK_HEALTH_REPORT_SUPPORT
+	priv->tx_reporter = NULL;
+#else
 	struct devlink_health_reporter *reporter;
 
-	reporter = devlink_port_health_reporter_create(priv->netdev->devlink_port,
-						       &mlx5_tx_reporter_ops,
+#ifndef HAVE_DEVLINK_PORT_HEALTH_REPORTER_CREATE
+	struct mlx5_core_dev *mdev = priv->mdev;
+	struct devlink *devlink;
+#endif
+#ifdef HAVE_DEVLINK_PORT_HEALTH_REPORTER_CREATE
+#ifdef HAVE_NET_DEVICE_DEVLINK_PORT
+	reporter = devlink_port_health_reporter_create(priv->netdev->devlink_port, &mlx5_tx_reporter_ops,
+#else
+	reporter = devlink_port_health_reporter_create(mlx5e_devlink_get_dl_port(priv), &mlx5_tx_reporter_ops,
+#endif
 						       MLX5_REPORTER_TX_GRACEFUL_PERIOD, priv);
+#else /* HAVE_DEVLINK_PORT_HEALTH_REPORTER_CREATE */
+	devlink = priv_to_devlink(mdev);
+	reporter =
+		 devlink_health_reporter_create(devlink, &mlx5_tx_reporter_ops,
+						MLX5_REPORTER_TX_GRACEFUL_PERIOD,
+#ifdef HAVE_DEVLINK_HEALTH_REPORTER_CREATE_5_ARGS
+						true,
+#endif
+						priv);
+#endif /* HAVE_DEVLINK_PORT_HEALTH_REPORTER_CREATE */
 	if (IS_ERR(reporter)) {
 		netdev_warn(priv->netdev,
 			    "Failed to create tx reporter, err = %ld\n",
@@ -606,6 +822,7 @@ void mlx5e_reporter_tx_create(struct mlx
 		return;
 	}
 	priv->tx_reporter = reporter;
+#endif /* HAVE_DEVLINK_HEALTH_REPORT_SUPPORT */
 }
 
 void mlx5e_reporter_tx_destroy(struct mlx5e_priv *priv)
@@ -613,6 +830,14 @@ void mlx5e_reporter_tx_destroy(struct ml
 	if (!priv->tx_reporter)
 		return;
 
+#ifdef HAVE_DEVLINK_HEALTH_REPORT_SUPPORT
+
+#ifdef HAVE_DEVLINK_PORT_HEALTH_REPORTER_DESTROY
+	devlink_port_health_reporter_destroy(priv->tx_reporter);
+#else
 	devlink_health_reporter_destroy(priv->tx_reporter);
+#endif /* HAVE_DEVLINK_PORT_HEALTH_REPORTER_DESTROY  */
+
+#endif /* HAVE_DEVLINK_HEALTH_REPORT_SUPPORT */
 	priv->tx_reporter = NULL;
 }
